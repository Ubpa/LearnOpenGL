# 5. 高级光照

## 5.1 Blinn-Phong

冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为1.0时地板会出现的效果：

![img](https://learnopengl-cn.github.io/img/05/01/advanced_lighting_phong_limit.png)

原因是视线与反射光线的夹角超过90°

![img](https://learnopengl-cn.github.io/img/05/01/advanced_lighting_over_90.png)

Blinn-Phong模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。
![img](https://learnopengl-cn.github.io/img/05/01/advanced_lighting_halfway_vector.png)

![1540824585203](assets/1540824585203.png)

效果如下

![img](https://learnopengl-cn.github.io/img/05/01/advanced_lighting_comparrison.png)

![img](https://learnopengl-cn.github.io/img/05/01/advanced_lighting_comparrison2.png)

## 5.2 Gamma校正

过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器有一个物理特性就是两倍的输入电压产生的不是两倍的亮度。输入电压产生约为输入电压的2.2次幂的亮度，这叫做监视器Gamma。

Gamma也叫灰度系数，每种显示设备都有自己的Gamma值，都不相同，有一个公式：设备输出亮度 = 电压的Gamma次幂，任何设备Gamma基本上都不会等于1，等于1是一种理想的线性状态，这种理想状态是：如果电压和亮度都是在0到1的区间，那么多少电压就等于多少亮度。对于CRT，Gamma通常为2.2，因而，输出亮度 = 输入电压的2.2次幂。

人类所感知的亮度恰好和CRT所显示出来相似的指数关系非常匹配。

![img](https://learnopengl-cn.github.io/img/05/02/gamma_correction_brightness.png)

![img](https://learnopengl-cn.github.io/img/05/02/gamma_correction_gamma_curves.png)

```c
void main()
{
    // do super fancy lighting 
    [...]
    // apply gamma correction
    float gamma = 2.2;
    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));
}
```

若要进行Gamma校正，需定义纹理为**sRGB纹理**，否则相当于进行了两次Gamma校正

![img](https://learnopengl-cn.github.io/img/05/02/gamma_correction_srgbtextures.png)

光的衰减也只需使用线性的，Gamma校正会将其变成二次。

![img](https://learnopengl-cn.github.io/img/05/02/gamma_correction_attenuation.png)

## 5.3 阴影映射

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_with_without.png)

### 5.3.1 原理

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_theory_spaces.png)

### 5.3.2 阴影失真

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne.png)

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne_diagram.png)

深度增加bias，这样黄线就会都处于平面之下。

bias的大小根据光线与平面法线的夹角而定，夹角越大，bias越大。

![1540906287862](assets/1540906287862.png)

### 5.3.3 视锥外采样

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_outside_frustum.png)

对于横向超出，使用`GL_CLAMP_TO_BORDER`来使z为1.0，即默认不处在阴影中

对于纵向超出(z>1.0)，默认不处在阴影中

```c
float ShadowCalculation(vec4 fragPosLightSpace)
{
    [...]
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}
```

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_over_sampling_fixed.png)

### 5.3.4 PCF

percentage-closer filtering

```c
float shadow = 0.0;
vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
for(int x = -1; x <= 1; ++x)
{
    for(int y = -1; y <= 1; ++y)
    {
        float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
        shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        
    }    
}
shadow /= 9.0;
```

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_soft_shadows.png)

## 5.4 点阴影

### 5.4.1 原理

![1540908281257](assets/1540908281257.png)

### 5.4.2 渲染技巧

- depthmap的纹理选择cubemap
- 集合着色器根据6个矩阵来变换顶点（通过内建变量face选择），输出到6个不同图层

### 5.4.3 PCF

```c
float shadow = 0.0;
float bias = 0.05; 
float samples = 4.0;
float offset = 0.1;
for(float x = -offset; x < offset; x += offset / (samples * 0.5))
{
    for(float y = -offset; y < offset; y += offset / (samples * 0.5))
    {
        for(float z = -offset; z < offset; z += offset / (samples * 0.5))
        {
            float closestDepth = texture(depthMap, fragToLight + vec3(x, y, z)).r; 
            closestDepth *= far_plane;   // Undo mapping [0;1]
            if(currentDepth - bias > closestDepth)
                shadow += 1.0;
        }
    }
}
shadow /= (samples * samples * samples);
```

总共27个样本，剔除彼此接近的方向，剩余20个

```c
vec3 sampleOffsetDirections[20] = vec3[]
(
   vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1), 
   vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),
   vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),
   vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),
   vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)
);
```

## 5.5 法线贴图

一般的方法都是逐顶点法向，然后每个fragment的法向由三角形插值得到。这样每个三角面片内部的法向变化是比较平滑的。考虑贴图的思路，可以将整个纹理的法向保存在贴图中，这样每个三角面片内部的法向是根据贴图获取来的，这样更加丰富了细节。

![img](https://learnopengl-cn.github.io/img/05/04/normal_mapping_surfaces.png)

每个fragment使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个fragment使用各自的法线，替代一个面上所有fragment使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。

应用到砖墙上，效果像这样：

![img](https://learnopengl-cn.github.io/img/05/04/normal_mapping_compare.png)

### 5.5.1 贴图

可以将法线向量的x、y、z元素储存到纹理中，代替颜色的r、g、b元素。法线向量的范围在-1到1之间，所以我们先要将其映射到0到1的范围：

```c
vec3 rgb_normal = normal * 0.5 + 0.5; // 从 [-1,1] 转换至 [0,1]
```

将法线向量变换为像这样的RGB颜色元素，我们就能把根据表面的形状的fragment的法线保存在2D纹理中。教程开头展示的那个砖块的例子的法线贴图如下所示：

![img](https://learnopengl-cn.github.io/img/05/04/normal_mapping_normal_map.png)

这会是一种偏蓝色调的纹理（你在网上找到的几乎所有法线贴图都是这样的）。这是因为所有法线的指向都偏向z轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从z轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。

> 绿色即表示y较大，朝上
>
> 红色即表示y较小，朝下
>
> 蓝色即表示z较大，朝外

### 5.5.2 方向问题

法线贴图的朝向是固定的，而实际fragment的法向并不是朝向正z方向，因此法向方向不正确，需要进行变换。

![img](https://learnopengl-cn.github.io/img/05/04/normal_mapping_ground_normals.png)

### 5.5.3 切线空间

切线空间是位于三角形表面上的空间

- N为法线
- T为切向，指向纹理的x轴
- B为副切向，指向纹理的y轴

![img](https://learnopengl-cn.github.io/img/05/04/normal_mapping_tbn_vectors.png)

只要求出N、T、B就能构造变换矩阵，将法线贴图的法向向量转换到切向空间中

![img](https://learnopengl-cn.github.io/img/05/04/normal_mapping_surface_edges.png)

![1540989683790](assets/1540989683790.png)

### 5.5.4 实现思路

先求出各顶点的T向量，B向量可以用叉乘来获得，为保证N和T垂直，可以使用Gram-Schmidt process

```c
vec3 T = normalize(vec3(model * vec4(tangent, 0.0)));
vec3 N = normalize(vec3(model * vec4(normal, 0.0)));
// re-orthogonalize T with respect to N
T = normalize(T - dot(T, N) * N);
// then retrieve perpendicular vector B with the cross product of T and N
vec3 B = cross(T, N);

mat3 TBN = mat3(T, B, N)
```

由此可以用来变换法线贴图的法向向量

```c
normal = texture(normalMap, fs_in.TexCoords).rgb;
normal = normalize(normal * 2.0 - 1.0);   
normal = normalize(fs_in.TBN * normal);
```